from abc import ABCMeta, abstractmethod
import numpy as np
import itertools as it


class KmeansDataImporter:
    """ abstract data importer """

    def __init__(self):
        pass

    __metaclass__ = ABCMeta

    @abstractmethod
    def get_data(self, size):
        raise NotImplementedError('subclasses must override get_data()!')

    def rewind(self):
        pass

    @abstractmethod
    def has_more_data(self):
        raise NotImplementedError('subclasses must override has_more_data()!')


class KmeansFileDataImporter(KmeansDataImporter):
    """
    Import data from text files. The data structure should be as follows:
    One point occupies one line.
    Each point consists of several floats with space as a separator.
    """
    def __init__(self, filename):
        super(KmeansFileDataImporter, self).__init__()
        self._fileName = filename
        self._file = None
        self._fileLineEnum = None
        self._hasMoreData = True
        self.init_file_input_stream()

    def init_file_input_stream(self):
        self._file = open(name=self._fileName)
        self._fileLineEnum = enumerate(self._file)

    # @profile
    def get_data(self, size):
        """
        When get_data is called, an array of #size data is returned.
        """
        data = []
        for i in xrange(0, size):
            line = next(self._fileLineEnum, None)
            if line is not None:
                _, line = line
                parts = line.split()
                data.append(np.array(parts, dtype=np.float))
            else:
                self._hasMoreData = False
                self.close_file()
                break

        return np.array(data)

    def rewind(self):
        """
        Reset the file pointer to the beginning.
        """
        self.init_file_input_stream()
        self._hasMoreData = True

    def has_more_data(self):
        """
        Test if the pointer is at the end of the file or not.
        """
        return self._hasMoreData

    def close_file(self):
        if self._file is not None and not self._file.closed:
            self._file.close()


class KmeansBinaryFileDataImporter(KmeansDataImporter):
    """
    Import data from a binary file. The file format should be as generated by numpy.save.
    """
    def __init__(self, filename):
        super(KmeansBinaryFileDataImporter, self).__init__()
        self._fileName = filename
        self._file = None
        self._hasMoreData = True
        self._position = 0
        self.init_file_input_stream()

    def init_file_input_stream(self):
        self._file = np.load(self._fileName, mmap_mode='r')

    # @profile
    def get_data(self, size):
        """
        When get_data is called, an array of #size data is returned.
        """
        start_position = self._position
        end_position = start_position + size - 1
        if len(self._file) < end_position:
            end_position = len(self._file)
        self._position += size
        if self._position > len(self._file):
            self._hasMoreData = False

        return self._file[start_position:end_position]

    def rewind(self):
        """
        Reset the file pointer to the beginning.
        """
        self._position = 0
        self._hasMoreData = True

    def has_more_data(self):
        """
        Test if the pointer is at the end of the file or not.
        """
        return self._hasMoreData

    def close_file(self):
        if self._file is not None and not self._file.closed:
            self._file.close()
